#!/usr/bin/env python
import re

'''
Here's a gift that should be familiar from long ago. I'm not sure if "haunted doll" is the best gift to wish a happy start to your marriage, but when all you have is a hammer...

Due to this being a cursed artifact, it has some limitations in how it can communicate. While a little more advanced then spirit rapping, this doll can only communicate by presenting itself as a USB keyboard. This means you should be able to connect it to any computer, open a notepad-esque application, and invoke it by double pressing Caps Lock twice. Keep in mind it can only "hear" the Num, Scroll, and Caps lock keys. If you interact with the document it's typing in the message will be messed up. You also need to use an editor that doesn't do automatic indentation. The doll is also only the master of a very ancient USB protocol, and may not be able to make itself heard on newer hardware. Using the included cable should make this more likely to work, but an older Windows machine is probably more likely to work then a new Mac.
'''

LINE_LEN = 70
CENTER = False
LINE_OFFSET = 0

out_file = 'src/entries.h'

HEADER_TOP = '''
// File generated by python\specify_story.py

#include "quiz_score.h"

char score_buffer[50];

void Exit();

void ShowScore(const char* buffer);

void NoOp(uint8_t from, uint8_t to, uint8_t choice) {}
'''

TEXT_BLOCKS = {
  'Start': (
    ["Hello Amelia and/or Paul! I'm the haunted doll Zozo!",
     "Tap the \\\"Caps Lock\\\" key to move the cursor.",
     "Double click it to select the response.",
     "Since this is for your wedding, how about a relationship quiz?"],
    ['Zozo?', 'Are you spyware?', 'Quiz', 'Exit'],
    None
  ),
  'Zozo?': (
    ["That's me!",
     "I usually talk over Ouija boards,",
     "but I'm trying to change with the times.",
     "At least I don't have to compete with the other",
     "haunted dolls on Ebay."],
    ['Are you spyware?', 'Quiz', 'Exit'],
    None
  ),
  'Are you spyware?': (
    ["Well, not sure why you'd trust me,",
     "but I can't actually listen to your key presses.",
     "I can only listen for the keys that trigger lights.",
     "You know, like scroll, num, and caps lock.",
     "I use black magic for my identity theft."],
    ['Zozo?', 'Quiz', 'Exit'],
    None
  ),
  'Quiz': (
    ["While you two are perfect for each other,",
     "what if instead of being flesh and blood humans,",
     "you were instead a pair of possessed dolls?",
     "Here are some questions to find out:\\n",
     "As you walk by a well, a fairy emerges.",
     "It says that she caught a watch you dropped and tries",
     "to return it to you. Do you:",
     "1. Take the Watch.",
     "2. Tell her you didn't drop anything.",
     "3. Run away.",
     "4. Try to catch it."],
    [('1', 'Question 2'), ('2', 'Question 2'), ('3', 'Question 2'), ('4', 'Question 2'), 'Exit'],
    'ClearScore();\nAddToScore(choice);'
  ),
  'Question 2': (
    ["You find a locked hidden door in your house. Do you:",
     "1. Cut the lock and check it out.",
     "2. Re-hide it.",
     "3. Scour the neighborhood for info.",
     "4. Drill a hole and send a camera in."],
    [('1', 'Question 3'), ('2', 'Question 3'), ('3', 'Question 3'), ('4', 'Question 3'), 'Exit'],
    'AddToScore(choice);'
  ),
  'Question 3': (
    ["You are transported into a Toy Story like world.",
     "Which if the following would you prefer as your tour guide?",
     "1. A Trolls doll",
     "2. A Bratz Doll",
     "3. Barbie",
     "4. A generic dollar store doll"],
    [('1', 'Complete'), ('2', 'Complete'), ('3', 'Complete'), ('4', 'Complete'), 'Exit'],
    'AddToScore(choice);'
  ),
  'Complete' : (
    ["Yay you finished!",
     "After tabulating your results, the dolls you most resonate with are:"],
    [('Restart', 'Start'), 'Exit'],
    'AddToScore(choice);\nCopyScoreStr(score_buffer);\nShowScore(score_buffer);'
  ),
  'Exit': (
    ['Good Bye!', 'May your love be as eternal as I am.'],
    [],
    'Exit();'
  ),
}

def list_to_prgmem(name, strings):
  ret = ''
  vars = []
  for i, string in enumerate(strings):
    var = f'{name}_{i}'
    vars.append(var)
    ret += f'const char {var}[] PROGMEM = "{string}";\n'
  ret += f'const char *const {name}[] PROGMEM = {{{", ".join(vars)}}};'
  return ret

def validate_entries():
  for key, entry in TEXT_BLOCKS.items():
    for line in entry[0]:
      if len(line) > LINE_LEN:
        print(f'Line {line} in {key} is {len(line) - LINE_LEN} too long')
        return False
    key_len = sum([len(choice) for choice in entry[1]]) + len(entry[1]) + 1
    if key_len > LINE_LEN:
      print(f'Choices in {key} are {key_len - LINE_LEN} too long')
      return False
    for choice in entry[1]:
      if type(choice) == tuple:
        choice = choice[1]
      if choice not in TEXT_BLOCKS:
        print(f'Choice {choice} in {key} not valid')
        return False
  print('Entries valid')
  return True

def label_match(label_set, new_labels):
  for key, old_set in label_set.items():
    if all([ a == b for a, b in zip(old_set, new_labels)]):
      return key
  return None

def test(key):
  print('=' * LINE_LEN + '\n')
  entry = TEXT_BLOCKS[key]
  for line in entry[0]:
    if CENTER:
      line_offset = int((LINE_LEN - len(line)) / 2)
    else:
      line_offset = LINE_OFFSET
    print(' ' * line_offset, end='')
    print(line)
  print()
  key_total = sum([len(choice) for choice in entry[1]])
  padding = int((LINE_LEN - key_total) / (len(entry[1]) + 1))
  for choice in entry[1]:
    print(' ' * padding, end='')
    print(choice, end='')
  print('\n')
  print('='*(LINE_LEN + 2))

def compile():
  with open(out_file, 'w') as fd:
    fd.write(HEADER_TOP + '\n')
    key_idx = {k: str(i) for i, k in enumerate(TEXT_BLOCKS.keys())}
    entries = []
    choices = []
    choice_labels = []
    callbacks = []
    choice_cache = {}
    for key, entry in TEXT_BLOCKS.items():
      key = re.sub(r"[^a-zA-Z\d]", "_", key)
      fixed_entry = []
      for line in entry[0]:
        if CENTER:
          line_offset = int((LINE_LEN - len(line)) / 2)
        else:
          line_offset = LINE_OFFSET
        fixed_entry.append(' ' * line_offset + line)
      for i in range(len(entry[1])):
        if type(entry[1][i]) != tuple:
          entry[1][i] = (entry[1][i], entry[1][i])
      fixed_entry = '\\n'.join(fixed_entry)
      fd.write(f'const char ENTRY_{key.upper()}[] PROGMEM = "{fixed_entry}";\n')
      fixed_choices = ', '.join([key_idx[i[1]] for i in entry[1]])
      fixed_labels = '", "'.join([i[0] for i in entry[1]])
      choices_label = 'CHOICES_LABELS_' + key.upper()
      fd.write(f'const uint8_t CHOICES_{key.upper()}[] = {{{fixed_choices}}};\n')
      found = label_match(choice_cache, fixed_labels)
      if found:
        choices_label = found
      else:
        fd.write(f'const char* const {choices_label}[] = {{"{fixed_labels}"}};\n')
        choice_cache[choices_label] = fixed_labels
      if entry[2]:
        func_name = 'Callback' + key.capitalize()
        fd.write(f'void {func_name}(uint8_t from, uint8_t to, uint8_t choice) {{\n{entry[2]}\n}}\n')
        callbacks.append(func_name)
      else:
        callbacks.append('NoOp')
      entries.append('ENTRY_' + key.upper())
      choices.append('CHOICES_' + key.upper())
      choice_labels.append(choices_label)
    entries_str = ', '.join(entries)
    choices_str = ', '.join(choices)
    choice_labels_str = ', '.join(choice_labels)
    choice_counts_str = ', '.join([str(len(x[1])) for x in TEXT_BLOCKS.values()])
    callback_str = ', '.join(callbacks)
    
    fd.write(f'const char* const* const MENU_LABELS[] = {{{choice_labels_str}}};\n')
    fd.write(f'const char* const ENTRIES[] = {{{entries_str}}};\n')
    fd.write(f'const uint8_t* const CHOICES[] = {{{choices_str}}};\n')
    fd.write(f'const uint8_t CHOICE_COUNTS[] = {{{choice_counts_str}}};\n')
    fd.write(f'void (*ENTRY_CALLBACKS[]) (uint8_t from, uint8_t to, uint8_t choice) = {{{callback_str}}};\n')

def main():
  if not validate_entries():
    return
  # test('one')
  compile()

  
  DOLL_ADJECTIVES = [
    "Glowing",
    "Whispering",
    "Floating",
    "Giggling",
    "Bent",
    "Cracked",
    "Eyeless",
    "Vibrating"
  ]
  DOLL_TYPES = [
    "Voodoo",
    "Chucky-esque",
    "Melted Wax",
    "Sewn Skin",
    "Non-Euclidean",
    "Porcelain",
    "Eldritch",
    "Clown"
  ]

  print(list_to_prgmem('DOLL_TYPES', DOLL_TYPES))
  print(list_to_prgmem('DOLL_ADJECTIVES', DOLL_ADJECTIVES))

if __name__ == "__main__":
  main()
